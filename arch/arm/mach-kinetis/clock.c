/*
 * (C) Copyright 2011, 2012
 * Emcraft Systems, <www.emcraft.com>
 * Alexander Potashev <aspotashev@emcraft.com>
 *
 * See file CREDITS for list of people who contributed to this
 * project.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */

#include <linux/types.h>
#include <linux/io.h>
#include <linux/clk.h>
#include <mach/clock.h>
#include <mach/kinetis.h>

#if defined(CONFIG_FB_IMX)
/*
 * Maximum values for the LCDC clock divisor and fraction
 */
/* LCDCDIV: 12 bits, up to 4096 */
#define KINETIS_LCDC_MAX_NUMERATOR	((KINETIS_SIM_CLKDIV3_LCDCDIV_MSK >> \
					KINETIS_SIM_CLKDIV3_LCDCDIV_BITS) + 1)
/* LCDCFRAC: 8 bits, up to 256 */
#define KINETIS_LCDC_MAX_DENOMINATOR	((KINETIS_SIM_CLKDIV3_LCDCFRAC_MSK >> \
					KINETIS_SIM_CLKDIV3_LCDCFRAC_BITS) + 1)
/*
 * Adjust the LCDC clock divider to produce a frequency as close as possible
 * to the requested value.
 * FIXME: Move this to the clk framework
 */
void kinetis_lcdc_clk_set_rate(struct clk *clk, unsigned long lcd_clk)
{
	/*
	 * Length limit for the continued fraction. In the worst case
	 * of the integer parts in the continued fraction being all ones
	 * (golden ratio), numerator and denominator of the evaluated continued
	 * fraction grow like Fibonacci numbers, or like powers of golden
	 * ratio. This is why for the length limit (N) we choose the logarithm
	 * of 4096 (LCDCDIV maximum value) to base of golden ratio (1.618...),
	 * plus a few extra array elements for safety.
	 */
	const int N = 20;

	/* Integer parts in the continued fraction */
	u32 seq[N];
	/* Indices in the "seq" array */
	int i, j;
	/* Temporary variables for evaluation of continued fraction */
	u32 a, b, c;
	/* Final numerator and denominator */
	u32 last_a = 1, last_b = 1;
	/* Target value, multiplied by 2**16 */
	u32 x;

	/* x = (base << 16) / clock */
	u64 tmp = (u64)clk_get_rate(clk) << 16;
	do_div(tmp, lcd_clk);
	x = (u32)tmp;

	/*
	 * Build the continued fraction (Diophantine approximation of "x")
	 */
	for (i = 0; i < N; i++) {
		/* floor(x) */
		seq[i] = x >> 16;

		/* Result is a/b, "c" is a helper variable */
		a = 1;
		b = 0;
		for (j = i; j >= 0; j--) {
			/* Partial fraction p_{next} = seq + p^{-1} */
			/* New numerator */
			c = seq[j] * a + b;
			/* New denominator */
			b = a;
			/* Write nominator into the correct variable */
			a = c;

			if (a > KINETIS_LCDC_MAX_NUMERATOR ||
			    b > KINETIS_LCDC_MAX_DENOMINATOR)
				break;
		}

		if (b > KINETIS_LCDC_MAX_DENOMINATOR ||
		    a > KINETIS_LCDC_MAX_NUMERATOR) {
			/* Stop approximation on exceeding of the limits */
			break;
		} else {
			/* Approximation is good, save it */
			last_a = a;
			last_b = b;
		}

		/* Keep fractional part */
		x &= 0xffff;
		/* Exit if we are already very close to the target value */
		if (x < 2)
			break;

		/* x = 1.0/x */
		x = ((u32)-1) / x;
	}

	/*
	 * Write LCDC clock divider values to the SIM_CLKDIV3 register
	 */
	KINETIS_SIM_RESET(clkdiv3, KINETIS_SIM_CLKDIV3_LCDCFRAC_MSK |
		KINETIS_SIM_CLKDIV3_LCDCDIV_MSK);
	KINETIS_SIM_SET(clkdiv3,
		((last_a - 1) << KINETIS_SIM_CLKDIV3_LCDCDIV_BITS) |
		((last_b - 1) << KINETIS_SIM_CLKDIV3_LCDCFRAC_BITS));
}

unsigned long kinetis_lcdc_clk_get_rate(struct clk *clk)
{
	/*
	 * Calculate the the actual clock generated by System Clock Divider 3
	 */
	return clk_get_rate(clk) /
		(((KINETIS_SIM_RD(clkdiv3) &
			KINETIS_SIM_CLKDIV3_LCDCDIV_MSK) >>
		KINETIS_SIM_CLKDIV3_LCDCDIV_BITS) + 1) *
		(((KINETIS_SIM_RD(clkdiv3) &
			KINETIS_SIM_CLKDIV3_LCDCFRAC_MSK) >>
		KINETIS_SIM_CLKDIV3_LCDCFRAC_BITS) + 1);
}

void kinetis_lcdc_start(void)
{
	KINETIS_SIM_SET(mcr, KINETIS_SIM_MCR_LCDSTART_MSK);
}
#endif /* CONFIG_FB_IMX */
